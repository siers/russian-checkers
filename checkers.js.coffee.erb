BLACK   = false
WHITE   = true
REGULAR = false
QUEEN   = true # Must be always true.
X       = 0
Y       = 1

# This is a mixin, and rules /logically/ actually extend piece, not vice versa.
class Rules
  bound = (cons) ->
    [x, y] = cons
    x >= 0 and x <= 7 and y >= 0 and y <= 7

  direction: ->
    if @color == BLACK then 1 else -1

  # Checks whether on a black square only.
  @black = (cons) ->
    [x, y] = cons ? @target
    (x + y) % 2 == 1
  black: @black

  diagonal: ->
    x = @cons[X] - @target[X]
    y = @cons[Y] - @target[Y]
    Math.abs(x) == Math.abs(y)

  # Checks whether the move is going towards the other end.
  fd: ->
  forward: ->
    (@target[Y] - @cons[Y]) == @direction()

  diagonals: (max_length = 1) ->
    _.chain([[-1, 1], [1, 1], [-1, -1], [1, -1]]).map((vec) =>
      targets = []
      length  = 1
      while length <= max_length
        cons = [@cons[X] + vec[X]*length, @cons[Y] + vec[Y]*length]
        length++

        targets.push cons if bound(cons)
      return undefined if targets.length == 0
      [targets, vec]
    ).compact().value()

  UNABLE = 2
  DONE   = 1
  WRONG  = 0
  # Did he do the obligatory attacking?
  attacked: ->
    plausible_vecs = _(@diagonals(2)).select ([[target, _], vec]) =>
      piece     = @set.get(target)
      plausible = piece && piece.color == !@color

    return UNABLE if plausible_vecs.length == 0

    did   = false
    empty = false

    _(plausible_vecs).each ([[beatable, next], vec]) =>
      piece = @set.get(next)
      empty = empty || true if piece == null
      did   = did   || empty and _.isEqual(next, @target)

    return DONE if did
    return UNABLE if not empty
    return WRONG

  valid: (cons) ->
    [@x, @y] = (@target = cons)
    return false unless @black()
    return false unless @diagonal()
    return false unless (attacked = @attacked())
    return false if attacked == UNABLE and not @forward()
    return true

class Piece extends Rules
  constructor: (@cons, @color, @queen, @set) ->
    @element()

  selected: (e) =>
    e.stopPropagation()
    @element.toggleClass('selected')

  piece = $("<div class='piece' />")

  element: ->
    @element = piece.
      clone(true).
      appendTo(Checkers.field).
      bind('click', @selected)

  classify: ->
    klass = ['piece']
    klass.push "p#{ "hgfedcba"[@cons[0]] }"
    klass.push "p#{ @cons[1]+1 }"
    klass.push "#{ if @color == WHITE then 'white' else 'black' }"
    klass.push "#{ if @queen then 'queen' else '' }"
    @element.attr('class', klass.join(' '))

  render: ->
    @classify()

class Pieces
  array: []
  constructor: ->
    for x in [0..7]
      @array.push([])
      for y in [0..7]
        _(@array).last().push(null)

  new: (args...) ->
    [[x, y], _...] = args
    @array[x][y] = new Piece(args..., this)

  get: (cons) ->
    try
      @array[cons[X]][cons[Y]]
    catch e
      $.log "Error on requesting #{ cons[X] }x#{ cons[Y] } from piece set."
      throw e

  each: (fun) ->
    _.chain(@array).flatten().compact().each(fun)

  move: (piece, cons) ->
    @array[piece.cons[X]][piece.cons[Y]] = null
    # A check of emptiness of the destination could be placed here.
    (@array[cons[X]][cons[Y]] = piece).cons = cons

class Moves
  positions: [] # board version list

  constructor: ->
    @positions.push @pieces

class Board extends Moves
  pieces: new Pieces
  unit: null # pixels per one square

  constructor: ->
    @create()
    super

  create: ->
    for x in [0..7]
      for y in [0..5]
        if Rules.black([x, y])
          y += 2 if y > 2
          @pieces.new([x, y],
            if y > 3 then WHITE else BLACK,
            if Math.random() * 3 > 1 then QUEEN else REGULAR)

  release: (e) => # Release can be anywhere.
    x    = Math.floor(e.originalEvent.layerX / @unit)
    y    = Math.floor(e.originalEvent.layerY / @unit)
    cons = [x, y]
    sel  = found = @find()
    @put(sel, cons) if found and sel.valid(cons)

  put: (piece, cons) -> # Put only where cons are valid.
    @pieces.move(piece, cons)
    piece.render()

  find: (fun = null) ->
    fun = fun || (p) -> p.element.is('.selected')
    ret = undefined

    @pieces.each (p) ->
      return ((ret = p) && false) if fun(p)

    ret

  render: ->
    @pieces.each (p) -> p.render()

Game.list.checkers = Checkers =
  init: (@field) ->
    @board = new Board
    @board.unit = @field.width() / 8
    @board.render()
    @field.addClass('checkers').bind('click', @board.release)

  stop: ->
    null
